%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Model
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{算法描述}
本文使用差分进化算法\cite{jqingfeng2017}求解转移轨道。
一般使用参数优化的方法是将推力离散化，
然后每个离散点的推力值算作一个参数，
优化每个离散点的推力值使得转移轨道的某些参数最优。
这样待优化的参数特别多\cite{dchengxing2011}，
并且如果发动机工作时间不固定，
那么待优化的参数个数也就不固定，
而一般的启发式优化算法都假设了不同个体(不同的解)的参数个数相等。
另外由于推力一般连续变化且变化幅度不大，
但启发式算法一般也都假设各个参数之间独立，
也就是说推力问题中相邻的离散点的值有一定的约束，
但启发式算法解决带约束的问题比较吃力。
不知道有没有启发式算法解决约束问题较好的例子。

为此，文献\cite{jbradley2005}提出了将发动机推力变化曲线用三次多项式(cubic polynomials)拟合的方法，
在出发点和到达点附近分别使用了一个三次多项式来拟合发动机的推力方向。
这一方法既解决了参数约束的问题也解决了参数不固定的问题，
更极大减小了参数数量，
但作者认为这种方法达不到最优解。
本文使用这种方法，
另外考虑地球轨道和火星轨道不共面的情况，
在推力方向中加入了俯仰角，
因此多了两个三次多项式。

文献\cite{jbradley2005}也提出了将发动机工作的起止时间也作为待优化参数的思想，
但没有提到如何处理超过参数变化范围的情况，
比如发动机工作时间不可能是负数。
就算在初始化时只生成正数解，
但交叉和变异操作也可能会生成负数。
另外发动机工作时间也不能太长。
考虑到探测器质量一直在下降，
总的轨道转移时间为$22464e3$秒，
因此将加速和减速阶段的发动机工作时间分别限制在
$12500e3$秒和$7500e3$秒以内。
使用非线性公式
\[T=k\arctan{x}^2\]
实施限制，
其中$k$的值在加速和减速阶段分别为$\frac{25000}{\pi}$和$\frac{15000}{\pi}$，
$x$为服从标准正态分布的随机数，
用于启发式算法的初始化。

损失函数的设计中需要考虑位置和速度向量以及燃料消耗。
优先考虑轨道转移能否成功，
因此将燃料消耗的系数设置为$0.01$。
损失函数为
\begin{equation*}
    e = ||\vec{r}_t-\vec{r}_s||^2
    + ||\vec{v}_t-\vec{v}_s||^2
    + 0.01T_w
\end{equation*}
其中$\vec{r}_t$和$\vec{v}_t$分别为给定到达点的位置和速度向量，
$\vec{r}_s$和$\vec{v}_s$分别为第260天时探测器的位置和速度向量，
$T_w$为发动机的开机时长，等价于燃料消耗。

前一节中提到将实际时间加快$10^4$倍，
还有其它一些参数，比如发动机推力$F$和燃料消耗速度$d_m$的换算如下
\begin{align*}
    &\bar{F}\left[\frac{\text{kg}\cdot(10^{-6}\text{km})}{(10^{-4}\text{s})^2}\right]
     = 10^2F\left[\frac{\text{kg}\cdot\text{km}}{\text{s}^2}\right] \\
    &\bar{d}_m\left[\frac{\text{kg}}{10^{-4}\text{s}}\right]
     = 10^4d_m\left[\frac{\text{kg}}{\text{s}}\right] \\
\end{align*}
设求解器的步长为$10^{-3}$，
则求解器一个步长对应10秒的实际时间，
转移轨道全程总共需要计算$2246400$个步长，
在个人电脑上计算完全程耗时约50秒。
为了能够使用启发式算法，
需要进一步加快速度。
保持距离换算关系不变，
将时间换算关系改为$\bar{t}=10^{-6}t$，
则总共需要计算$22464$个步长，
一个步长对应$1000$秒。
其它换算关系为
\begin{align*}
    &\bar{v} = v \\
    &\bar{a} = 10^6a \\
    &\bar{\mu} = 10^{-6}\mu \\
    &\bar{F} = 10^6F \\
    &\bar{d}_m = 10^6d_m \\
\end{align*}

求出最优解后还需要将时间从$10^{-6}t$换回$10^{-4}t$。
若跑优化算法时使用的多项式为(以二次多项式为例，三次多项式同理)
\[f(t)=at^2+bt+c\]
则实际仿真时，开头的加速段要改成
\[f(t)=a\left(\frac{t}{100}\right)^2+b\left(\frac{t}{100}\right)+c\]

